<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Grayscale Snake</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --accent-color: #ffffff;
            --snake-color: #aaaaaa;
            --food-color: #ffffff;
            --grid-color: #222222;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(18, 18, 18, 0.8);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s ease;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            animation: fadeInDown 1s ease-out;
        }

        p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.8;
            animation: fadeInUp 1s ease-out 0.5s both;
        }

        .controls-info {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            animation: fadeInUp 1s ease-out 0.8s both;
        }

        .key {
            border: 1px solid var(--text-color);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            text-transform: uppercase;
        }

        #score-board {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 10;
            opacity: 0.7;
        }

        #high-score-display {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        #initials-input {
            background: transparent;
            border: none;
            border-bottom: 2px solid var(--text-color);
            color: var(--text-color);
            font-size: 2rem;
            width: 100px;
            text-align: center;
            text-transform: uppercase;
            font-family: 'Inter', sans-serif;
            margin-bottom: 1rem;
            outline: none;
        }

        .blink {
            animation: blinker 1.5s linear infinite;
        }

        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

    </style>
</head>
<body>

    <div id="score-board">Score: <span id="current-score">0</span></div>

    <div id="ui-layer">
        <h1 id="game-title">SNAKE</h1>
        <div id="start-screen-content">
            <p>Use <strong>W A S D</strong> to move</p>
            <div class="controls-info">
                <span class="key">W</span>
                <span class="key">A</span>
                <span class="key">S</span>
                <span class="key">D</span>
            </div>
            <p class="blink">Press any key to start</p>
        </div>
        <div id="game-over-content" style="display: none; text-align: center;">
            <h2 id="game-over-title">Game Over</h2>
            <div id="high-score-display">High Score: <span id="high-score-val">0</span> <span id="high-score-name"></span></div>
            <p>Your Score: <span id="final-score">0</span></p>

            <div id="new-high-score-section" style="display: none;">
                <p>ENTER INITIALS</p>
                <input type="text" id="initials-input" maxlength="3" autofocus autocomplete="off" />
                <p><small>PRESS ENTER</small></p>
            </div>

            <p id="restart-msg" class="blink">Press any key to restart</p>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const startContent = document.getElementById('start-screen-content');
        const gameOverContent = document.getElementById('game-over-content');
        const gameOverTitle = document.getElementById('game-over-title');
        const scoreEl = document.getElementById('current-score');
        const finalScoreEl = document.getElementById('final-score');
        const highScoreValEl = document.getElementById('high-score-val');
        const highScoreNameEl = document.getElementById('high-score-name');
        const newHighScoreSection = document.getElementById('new-high-score-section');
        const initialsInput = document.getElementById('initials-input');
        const restartMsg = document.getElementById('restart-msg');

        // Game Configuration
        const GRID_SIZE = 20;
        let tileCountX = 20;
        let tileCountY = 20;

        // Game State
        let snake = [];
        let food = { x: 15, y: 15 };
        let dx = 0;
        let dy = 0;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
        let highScoreName = localStorage.getItem('snakeHighScoreName') || '';
        let gameState = 'START'; // START, PLAYING, GAMEOVER, INPUT
        let lastTime = 0;
        const gameSpeed = 100; // ms per frame logic
        let timeAccumulator = 0;

        // Initialize UI
        highScoreValEl.innerText = highScore;
        highScoreNameEl.innerText = highScoreName ? `(${highScoreName})` : '';

        // Expose for testing
        window.snake = snake;
        window.score = score;
        window.endGame = endGame;
        window.tileCountX = tileCountX;

        // Resize handling
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            tileCountX = Math.floor(canvas.width / GRID_SIZE);
            tileCountY = Math.floor(canvas.height / GRID_SIZE);
        }
        window.addEventListener('resize', resize);
        resize();

        // Input handling
        document.addEventListener('keydown', handleInput);
        initialsInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
            if (e.key === 'Enter') {
                submitHighScore();
            }
        });

        function handleInput(e) {
            if (gameState === 'INPUT') return;

            if (gameState === 'START' || gameState === 'GAMEOVER') {
                resetGame();
                gameState = 'PLAYING';
                uiLayer.classList.add('hidden');
                // Default start direction
                dx = 1;
                dy = 0;
                return;
            }

            const key = e.key.toLowerCase();

            // Prevent reversing
            if ((key === 'w' || key === 'arrowup') && dy === 0) { dx = 0; dy = -1; }
            if ((key === 's' || key === 'arrowdown') && dy === 0) { dx = 0; dy = 1; }
            if ((key === 'a' || key === 'arrowleft') && dx === 0) { dx = -1; dy = 0; }
            if ((key === 'd' || key === 'arrowright') && dx === 0) { dx = 1; dy = 0; }
        }

        function resetGame() {
            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            score = 0;
            scoreEl.innerText = score;
            placeFood();
            startContent.style.display = 'block';
            gameOverContent.style.display = 'none';
        }

        function placeFood() {
            food = {
                x: Math.floor(Math.random() * tileCountX),
                y: Math.floor(Math.random() * tileCountY)
            };
            // Make sure food doesn't spawn on snake
            for (let part of snake) {
                if (part.x === food.x && part.y === food.y) {
                    placeFood();
                    break;
                }
            }
        }

        function update() {
            // Sync window vars for testing
            window.snake = snake;
            window.score = score;
            window.dx = dx;
            window.dy = dy;
            window.tileCountX = tileCountX;

            if (gameState !== 'PLAYING') return;

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Wrap around
            if (head.x < 0) head.x = tileCountX - 1;
            if (head.x >= tileCountX) head.x = 0;
            if (head.y < 0) head.y = tileCountY - 1;
            if (head.y >= tileCountY) head.y = 0;

            // Self collision
            for (let part of snake) {
                if (part.x === head.x && part.y === head.y) {
                    endGame();
                    return;
                }
            }

            snake.unshift(head);

            // Eat food
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreEl.innerText = score;
                placeFood();
            } else {
                snake.pop();
            }
        }

        function endGame() {
            finalScoreEl.innerText = score;
            startContent.style.display = 'none';
            gameOverContent.style.display = 'block';
            uiLayer.classList.remove('hidden');

            if (score > highScore) {
                gameState = 'INPUT';
                gameOverTitle.innerText = "New High Score!";
                newHighScoreSection.style.display = 'block';
                restartMsg.style.display = 'none';
                initialsInput.value = '';
                setTimeout(() => initialsInput.focus(), 100); // Delay to ensure visibility
            } else {
                gameState = 'GAMEOVER';
                gameOverTitle.innerText = "Game Over";
                newHighScoreSection.style.display = 'none';
                restartMsg.style.display = 'block';
                highScoreValEl.innerText = highScore;
                highScoreNameEl.innerText = highScoreName ? `(${highScoreName})` : '';
            }
        }

        function submitHighScore() {
            const name = initialsInput.value.toUpperCase() || 'UNK';
            highScore = score;
            highScoreName = name;

            localStorage.setItem('snakeHighScore', highScore);
            localStorage.setItem('snakeHighScoreName', highScoreName);

            // Update UI
            highScoreValEl.innerText = highScore;
            highScoreNameEl.innerText = `(${highScoreName})`;

            // Switch back to normal game over state
            gameState = 'GAMEOVER';
            gameOverTitle.innerText = "Game Over";
            newHighScoreSection.style.display = 'none';
            restartMsg.style.display = 'block';
        }

        // Rendering
        function draw(timestamp) {
            // Clear screen
            ctx.fillStyle = '#121212';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid (Optional, for style)
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for(let x=0; x<canvas.width; x+=GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for(let y=0; y<canvas.height; y+=GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw Food with glow
            const foodX = food.x * GRID_SIZE;
            const foodY = food.y * GRID_SIZE;
            const pulse = Math.sin(timestamp / 200) * 5 + 5; // 0 to 10

            ctx.shadowBlur = 10 + pulse;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(foodX + 2, foodY + 2, GRID_SIZE - 4, GRID_SIZE - 4);
            ctx.shadowBlur = 0;

            // Draw Snake
            ctx.fillStyle = '#aaaaaa';
            snake.forEach((part, index) => {
                const x = part.x * GRID_SIZE;
                const y = part.y * GRID_SIZE;

                // Head is brighter
                if (index === 0) {
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                } else {
                    ctx.fillStyle = '#aaaaaa';
                    ctx.shadowBlur = 0;
                }

                ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
            });

            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            timeAccumulator += deltaTime;

            // Update logic at fixed time step
            if (timeAccumulator >= gameSpeed) {
                update();
                timeAccumulator = 0; // or timeAccumulator -= gameSpeed for catch up
            }

            draw(timestamp);
        }

        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
